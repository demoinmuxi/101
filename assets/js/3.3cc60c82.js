(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{277:function(t,e,r){t.exports=r.p+"assets/img/task01.bbcd160b.png"},278:function(t,e,r){t.exports=r.p+"assets/img/task02.b1c66e12.png"},279:function(t,e,r){t.exports=r.p+"assets/img/task3.5a2b03a2.png"},280:function(t,e,r){t.exports=r.p+"assets/img/task4-1.9ee76532.png"},281:function(t,e,r){t.exports=r.p+"assets/img/task4-2.abb53c39.png"},282:function(t,e,r){t.exports=r.p+"assets/img/task5.2662906f.png"},283:function(t,e){t.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAy8AAAFqCAMAAAAk+ZX0AAAAAXNSR0IArs4c6QAAADNQTFRF//////0u/yQC/5SR//31//2T//0G//0IAjL//yQGjZf/9fX//zYsJD7/s7Nk/7MIITz/lYix/gAAAm1JREFUeNrt0zECgjAQALBqqyAg7f9fywbuDHgl+UNSAgAAAICbKzmKF72Zopj3L/kZRX3Tl3WMYvr58gmiDvTFF1/wxRd88QVffMEXX3zxxRdffPHFF3zxBV98wRdf8MUXfPHFF1988QVffMEXX/DFF3zxBV988cUXX3zBF1/wxRd88QVffMEXX3zxxRdf8MUXfPEFX3zBF1/wxRdffPHFF3zxBV98wRdf8MUXfPHFF1988QVffMEXX/DFF3zxBV988cUXX3zBF1/wxRd88QVffMEXX3zxxRdffPHFF3zxBV98wRdf8MUXfPHFF1988QVffMEXX/DFF3zxBV988cUXX3zBF1/wxRd88QVffMEXX3zxxRdf8MUXfPEFX3zBF1/wxRdffPHFF3zxBV98wRdf8MUXfPHFF1988QVffMEXX/DFF3zxBV988cUXX3zBF1/wxRd88QVffMEXX3zxxRdffPHFF3zxBV98wRdf8MUXfPHFF1988QVffMEXX/DFF3zxBV988cUXX3zBF1/wxRd88QVffMEXX3zx5a+/LFHUB31Z2zeGdnwpcJU5jAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ20c8bgFlXx0KgAAAABJRU5ErkJggg=="},299:function(t,e,r){"use strict";r.r(e);var v=r(38),_=Object(v.a)({},function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"大一上学期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#大一上学期","aria-hidden":"true"}},[t._v("#")]),t._v(" 大一上学期")]),t._v(" "),v("blockquote",[v("p",[t._v("编写中")])]),t._v(" "),v("h2",{attrs:{id:"模块一：html-css-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块一：html-css-基础","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块一：HTML + CSS 基础")]),t._v(" "),v("ul",[v("li",[t._v("学习 HTML 和 CSS，参考资料：\n"),v("ul",[v("li",[v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/HTML",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTML-MDN"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/CSS",target:"_blank",rel:"noopener noreferrer"}},[t._v("CSS-MDN"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"http://zh.learnlayout.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("学习 CSS 布局"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://css-tricks.com/snippets/css/a-guide-to-flexbox/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Flex 布局"),v("OutboundLink")],1)])])])]),t._v(" "),v("p",[v("strong",[t._v("完成以下 Task(每周完成一项 task）")]),t._v("（保存在"),v("a",{attrs:{href:"http://js.jirengu.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSBIN"),v("OutboundLink")],1),t._v("里，完成任务后把链接发到自己的进度文档中）")]),t._v(" "),v("h3",{attrs:{id:"task1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task1","aria-hidden":"true"}},[t._v("#")]),t._v(" Task1")]),t._v(" "),v("p",[t._v("请实现以下表格的"),v("strong",[t._v("HTML")]),t._v("部分\n"),v("img",{attrs:{src:r(277),alt:"表格"}}),t._v("\n提示：注意"),v("code",[t._v("<thead>")]),t._v(","),v("code",[t._v("<tbody>")]),t._v("的使用")]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"task-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-2","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 2")]),t._v(" "),v("p",[t._v("请实现以下表单的 HTML 部分\n"),v("img",{attrs:{src:r(278),alt:"图片名称"}})]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"task3"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task3","aria-hidden":"true"}},[t._v("#")]),t._v(" Task3")]),t._v(" "),v("p",[t._v("修改这个"),v("a",{attrs:{href:"https://codepen.io/anon/pen/VBwqaL",target:"_blank",rel:"noopener noreferrer"}},[t._v("模板"),v("OutboundLink")],1),t._v("，通过 CSS 实现以下效果\n"),v("img",{attrs:{src:r(279),alt:"图片效果"}})]),t._v(" "),v("p",[t._v("要求使用浮动布局方法，并需要清除浮动。")]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"task4"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task4","aria-hidden":"true"}},[t._v("#")]),t._v(" Task4")]),t._v(" "),v("ul",[v("li",[t._v("实现 "),v("a",{attrs:{href:"https://css-tricks.com/snippets/css/a-guide-to-flexbox/",target:"_blank",rel:"noopener noreferrer"}},[t._v("A Guide To Flex"),v("OutboundLink")],1),t._v("中最后的练习")]),t._v(" "),v("li",[t._v("实现以下效果（Flex 布局实现垂直居中）：\n"),v("img",{attrs:{src:r(280),alt:"图片效果"}})]),t._v(" "),v("li",[t._v("修改"),v("a",{attrs:{href:"https://codepen.io/anon/pen/RBwEvg",target:"_blank",rel:"noopener noreferrer"}},[t._v("模板"),v("OutboundLink")],1),t._v("实现以下效果（通过 Flex 布局实现水平居中，替换当前 display:inline 实现）：\n"),v("img",{attrs:{src:r(281),alt:"图片效果"}})])]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"task5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task5","aria-hidden":"true"}},[t._v("#")]),t._v(" Task5")]),t._v(" "),v("p",[t._v("实现如下效果：\nTips:两个扇形定位在矩形的两角，矩形水平垂直居中，通过绝对定位实现\n"),v("img",{attrs:{src:r(282),alt:"图片名称"}})]),t._v(" "),v("hr"),t._v(" "),v("h3",{attrs:{id:"task6"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task6","aria-hidden":"true"}},[t._v("#")]),t._v(" Task6")]),t._v(" "),v("p",[t._v("分别通过“两边自适应，中间定宽”和“两边定宽，中间自适应”的方式实现基本效果：\n"),v("img",{attrs:{src:r(283),alt:"图片效果"}})]),t._v(" "),v("h2",{attrs:{id:"模块二：页面重构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块二：页面重构","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块二：页面重构")]),t._v(" "),v("h3",{attrs:{id:"task-1"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-1","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 1")]),t._v(" "),v("p",[t._v("重构"),v("a",{attrs:{href:"/101/xueer.png"}},[t._v("学而")]),t._v("首页，做出一个和它一模一样的页面出来。并使用 Github 的 gh-pages 分支部署静态页面。")]),t._v(" "),v("p",[v("em",[t._v("团队内同学可以访问蓝湖上的设计稿，看标注和样式比较方便。具体链接团队内获取")])]),t._v(" "),v("p",[t._v("要求：")]),t._v(" "),v("ul",[v("li",[t._v("HTML 与 CSS 分离（样式与结构分离）。")]),t._v(" "),v("li",[t._v("像素级还原。")]),t._v(" "),v("li",[t._v("只需实现静态页面。JS 效果不要求，比如推荐选项卡切换，点击按钮查看更多之类的都不用。")]),t._v(" "),v("li",[t._v("注意页面为"),v("strong",[t._v("定宽居中")]),t._v("布局。")]),t._v(" "),v("li",[t._v("注意通过重复使用同一个 Class，或者组合不同的 Class 来复用样式。")]),t._v(" "),v("li",[t._v("使用 Git 作为版本控制工具，利用 Github 的 gh-pages 分支托管页面。最后在进度里发链接。")])]),t._v(" "),v("h2",{attrs:{id:"模块三：javascript-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块三：javascript-基础","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块三：JavaScript 基础")]),t._v(" "),v("p",[t._v("木犀前端组唯一官方指定权威教材："),v("a",{attrs:{href:"http://eloquentjavascript.net/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Eloquent JavaScript (第三版)"),v("OutboundLink")],1)]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://wizardforcel.gitbooks.io/eloquent-js-3e/content/",target:"_blank",rel:"noopener noreferrer"}},[t._v("中文翻译"),v("OutboundLink")],1)])]),t._v(" "),v("p",[v("em",[t._v("推荐阅读英文原版，中文翻译作为参考，作者行文飘逸，中文翻译比较别扭，而且以后总是要看英文的，不如早点")])]),t._v(" "),v("p",[v("em",[t._v("可以提供 PDF 打印服务，完美装订，价格低廉，方便随时随地看书，有需要团队内联系")])]),t._v(" "),v("p",[t._v("参考资料：")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://item.jd.com/12123997.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript学习指南 第3版"),v("OutboundLink")],1),t._v(" 推荐购买，作为语言语法和特性的参考书")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide",target:"_blank",rel:"noopener noreferrer"}},[t._v("MDN JavaScript 指南"),v("OutboundLink")],1)])]),t._v(" "),v("h3",{attrs:{id:"task-0：导读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-0：导读","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 0：导读")]),t._v(" "),v("p",[t._v("阅读教材的"),v("a",{attrs:{href:"https://eloquentjavascript.net/00_intro.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("介绍（Introduction）章节"),v("OutboundLink")],1),t._v("。并阅读这篇教程"),v("a",{attrs:{href:"https://www.yuque.com/docs/share/2bd2bbdc-b87e-4cae-9fa7-bf2bce7e88d1",target:"_blank",rel:"noopener noreferrer"}},[t._v("EloquentJS 第一讲：介绍"),v("OutboundLink")],1),t._v("。了解 Eloquent JS 这本书，作者对编程学习的看法，以及 JS 和前端的前世今生。")]),t._v(" "),v("h3",{attrs:{id:"task-1：基础语法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-1：基础语法","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 1：基础语法")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("1-2")]),t._v(" 章并"),v("strong",[t._v("完成书上习题，上传到 Github")]),t._v("\n可以在"),v("a",{attrs:{href:"https://eloquentjavascript.net/code/",target:"_blank",rel:"noopener noreferrer"}},[t._v("这里"),v("OutboundLink")],1),t._v("测试代码")]),t._v(" "),v("p",[t._v("推荐流程：先看书，W3cshool 和 MDN 的教程先看基础语法部分。然后试着自己写一下（自己练习 JS 可以用 "),v("a",{attrs:{href:"http://js.jirengu.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JSBin"),v("OutboundLink")],1),t._v("/"),v("a",{attrs:{href:"https://codepen.io/",target:"_blank",rel:"noopener noreferrer"}},[t._v("CodePen"),v("OutboundLink")],1),t._v("/本地 HTML 文件/浏览器 Console/Nodejs 等多种环境），刷题中遇到困难多 Google")]),t._v(" "),v("p",[t._v("辅助教程"),v("a",{attrs:{href:"https://www.yuque.com/docs/share/421c50f9-5bf4-403b-8284-1d1b9fe548d1",target:"_blank",rel:"noopener noreferrer"}},[t._v("EloquentJS 第二讲：程序结构"),v("OutboundLink")],1)]),t._v(" "),v("p",[v("strong",[t._v("知识要点：")])]),t._v(" "),v("p",[v("em",[t._v("第一章")])]),t._v(" "),v("ul",[v("li",[t._v("值（Value）：计算机中所有数据的都是一个值，存储方式是二进制的编码。这部分是很关键的计算机基础知识，可以看"),v("a",{attrs:{href:"https://item.jd.com/11116026.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("《编码》"),v("OutboundLink")],1),t._v("这本书了解")]),t._v(" "),v("li",[t._v("基本数据类型：数字，字符串，布尔，"),v("em",[t._v("null 和 undefined")])]),t._v(" "),v("li",[t._v("运算符：算术，一元（unary），比较，逻辑。逻辑运算符比较常用，要了解"),v("em",[t._v("短路特性")]),t._v("（Short-circuiting of logical operators）。")]),t._v(" "),v("li",[t._v("JS 的自动类型转换（Automatic type conversion）。JS 是"),v("em",[t._v("弱类型语言")]),t._v("，不同类型之间会有"),v("em",[t._v("隐式转换")]),t._v("（Implict type conversion）。")])]),t._v(" "),v("p",[v("em",[t._v("第二章")])]),t._v(" "),v("ul",[v("li",[t._v("表达式（Expression）和语句（Statement）")]),t._v(" "),v("li",[t._v("变量（绑定（Bindings）），使用 var，const，let 关键字，了解"),v("em",[t._v("三者之间的区别")])]),t._v(" "),v("li",[t._v("变量名的规则，保留字不能作为变量名，同时变量名不能以数字开头，也不能包含 $ 或者 _ 之外的特殊字符")]),t._v(" "),v("li",[t._v("函数（Function）的概念，调用的方式")]),t._v(" "),v("li",[t._v("函数的返回值和"),v("em",[t._v("副作用")]),t._v("（Side effect）")]),t._v(" "),v("li",[t._v("控制流（Control flow）：条件，循环，switch 语句")]),t._v(" "),v("li",[t._v("跳出循环的方式，for 循环常用的 ++，+=，-=，-- 等操作符")]),t._v(" "),v("li",[t._v("驼峰命名法（Camel Case）")]),t._v(" "),v("li",[t._v("注释（Comment）")])]),t._v(" "),v("p",[t._v("书上讲到的知识点，有一些只是提到，没有很仔细的讲。因此这里推荐一些专题学习，可以自行搜索资料（"),v("strong",[t._v("谷歌搜！")]),t._v("），进一步了解，写一些总结学习的博客或者做一些分享：")]),t._v(" "),v("ul",[v("li",[t._v("在 JS 中 0.1 + 0.2 为什么不等于 0.3？ JS 中 number 底层的存储格式是什么？（IEEE 754 浮点数）")]),t._v(" "),v("li",[t._v("var，const，let 关键字的区别是什么？（块级作用域，暂时性死区（Temporal Dead Zone））")]),t._v(" "),v("li",[t._v("什么是函数的副作用？")]),t._v(" "),v("li",[t._v("什么是弱类型语言？语言在类型上有哪些分类？JS 的隐式类型转换的规则是什么？")]),t._v(" "),v("li",[t._v("什么是 JS 逻辑操作符的短路特性？这个特性在平时的应用是？")])]),t._v(" "),v("h3",{attrs:{id:"task-2：函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-2：函数","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 2：函数")]),t._v(" "),v("p",[t._v("函数是 JS 中的"),v("strong",[t._v("一等公民")]),t._v("，也是程序运行的主要单位。将逻辑封装为一个一个职责单一的函数，避免重复的编写代码，可以让整个程序的可读性，可维护性都大大提升。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("3")]),t._v(" 章并"),v("strong",[t._v("完成书上习题，上传到 Github")])]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[t._v("函数定义的方式。函数表达式 vs 函数声明。函数声明要注意声明提升")]),t._v(" "),v("li",[t._v("函数的返回值：可以有，可以没有，没有则默认返回 undefined。函数可以制造副作用，也可以返回值")]),t._v(" "),v("li",[t._v("作用域（Scope）：全局（Global）作用域，函数作用域，块级（Block）作用域")]),t._v(" "),v("li",[t._v("作用域可以层层嵌套，形成一个作用域链")]),t._v(" "),v("li",[t._v("作用域可以继承（看到/引用）上层作用域的变量，但不能看到子作用域的")]),t._v(" "),v("li",[t._v("词法作用域（Lexical scoping）")]),t._v(" "),v("li",[t._v("箭头函数（Arrow function）")]),t._v(" "),v("li",[t._v("调用栈（Call stack）")]),t._v(" "),v("li",[t._v("函数的参数（Paramater），参数默认都是可选的。可以指定参数的默认值")]),t._v(" "),v("li",[t._v("递归（Recursion）的概念")]),t._v(" "),v("li",[t._v("闭包（Closure）的概念")]),t._v(" "),v("li",[t._v("添加函数的时机，什么时候应该新增一个函数？")]),t._v(" "),v("li",[t._v("副作用与纯函数（Pure function）的概念")])]),t._v(" "),v("p",[t._v("函数很重要，本章的内容比较多，因此推荐花一些时间对一些概念做"),v("strong",[t._v("针对性学习")]),t._v("（推荐谷歌和知乎搜索）：")]),t._v(" "),v("ul",[v("li",[t._v("编程语言中作用域的概念")]),t._v(" "),v("li",[t._v("JS ES6 新增的词法作用域是指什么？之前 JS 的作用域是什么样的（这部分和前一个 Task 的 let,const vs var 关键字有很大联系）")]),t._v(" "),v("li",[t._v("词法作用域 vs 动态作用域")]),t._v(" "),v("li",[t._v("闭包（Closure）的概念")]),t._v(" "),v("li",[t._v("递归（Recursion）的概念，"),v("a",{attrs:{href:"http://www.nowamagic.net/librarys/veda/detail/2314",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考-用归纳法来理解递归"),v("OutboundLink")],1),t._v("-"),v("a",{attrs:{href:"http://www.nowamagic.net/librarys/veda/detail/2315",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考-递归需要满足的两个条件"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("li",[t._v("纯函数是指什么？什么时候应该写纯函数")]),t._v(" "),v("li",[t._v("什么时候应该新增一个函数？（学好这个对于写优雅的代码至关重要）")])]),t._v(" "),v("h3",{attrs:{id:"task-3：对象，数组以及字符串"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-3：对象，数组以及字符串","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 3：对象，数组以及字符串")]),t._v(" "),v("p",[t._v("对象和数组其实都是把很多值集合起来变成一个复杂的新的值，所以也可以把这些类型叫集合类型（逻辑上的概念，方便理解，不是语言规范）。对象是通过 key 去取不同的值，而数组是通过下标。主要的区别就是这样。同时对象和数组是引用类型，不同于原始类型，一个对象或者数组被赋值给其他的变量时，其实是传递了一个引用（学过 C 语言指针的话，其实就是传递了内存地址）。原始类型的话，传递的就是值本身了。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("4")]),t._v(" 章并"),v("strong",[t._v("完成书上习题，上传到 Github")])]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[t._v("数组（Array）概念和语法")]),t._v(" "),v("li",[t._v("属性（Properties）和方法（Methods）")]),t._v(" "),v("li",[t._v("对象（Object）概念和语法")]),t._v(" "),v("li",[t._v("数组其实也是一种对象，只是比较特殊，有 length 属性，可以用下标访问（但不是有数字属性和 length 属性的对象就是数组！）")]),t._v(" "),v("li",[t._v("可变（Mutability） vs 不可变（Immutability），对象直接比较是在比较引用（reference）")]),t._v(" "),v("li",[t._v("Object.key 和 Object.assign 两个API")]),t._v(" "),v("li",[t._v("数组的常用属性和方法（push, pop, unshift, shift, indexOf, lastIndexOf, slice, concat）")]),t._v(" "),v("li",[t._v("字符串的常用属性和方法（length, toUpperCase, slice, indexOf, trim, padStart, split, join, repeat）")]),t._v(" "),v("li",[t._v("剩余参数（Rest parameters)")]),t._v(" "),v("li",[t._v("解构（Destructuring）")]),t._v(" "),v("li",[t._v("内置的 Math 对象")]),t._v(" "),v("li",[t._v("JSON 数据格式以及，JSON.stringify 和 JSON.parse 两个 API")])]),t._v(" "),v("h3",{attrs:{id:"task-4：高阶函数-面向对象-原型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-4：高阶函数-面向对象-原型","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 4：高阶函数 && 面向对象 && 原型")]),t._v(" "),v("p",[t._v("这个 Task 介绍了高阶函数这个重要的概念，这个概念介绍了如何通过组合不同的函数来表达复杂的逻辑。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("5-6")]),t._v(" 章并"),v("strong",[t._v("完成书上习题，上传到 Github")])]),t._v(" "),v("p",[t._v("知识点：")]),t._v(" "),v("p",[v("em",[t._v("高阶函数")])]),t._v(" "),v("ul",[v("li",[t._v("高阶函数（Higher order function）：接受一个函数作为参数，或者返回一个函数的函数。")]),t._v(" "),v("li",[t._v("函数是一种抽象（Abstraction），高阶函数的存在让我们可以任意组合这些抽象。我们编写一个一个小的逻辑单元，每个单元只负责一个小的环节（单一职责），通过"),v("strong",[t._v("组合")]),t._v("这些函数，我们就可以表达复杂的逻辑，并且保证了代码的可维护性")]),t._v(" "),v("li",[t._v("高阶函数如果接受一个函数作为参数，一般会在内部调用这个函数，这样从外界来看，调用这个高阶函数就组合了高阶函数自身和传入函数两者的功能，通过多层高阶函数调用，可以进行复杂的组合。")]),t._v(" "),v("li",[t._v("高阶函数如果接受一个函数作为参数，也可能不在内部调用这个函数，而是返回一个新的函数，这个新的函数包装了传入的函数，并添加了附加的逻辑。这也是一种对抽象的组合。")]),t._v(" "),v("li",[t._v("高阶函数如果不接受一个函数作为参数，就一定会返回一个新函数，这个新函数绑定了传入的参数。通过调用这个高阶函数，可以生成新的函数，类似一个函数工厂")]),t._v(" "),v("li",[t._v("数组的高阶函数系列方法：map，reduce，filter")]),t._v(" "),v("li",[t._v("字符编码概念：unicode，code unit，code point，UTF16 这些概念。推荐阅读"),v("a",{attrs:{href:"https://dmitripavlutin.com/what-every-javascript-developer-should-know-about-unicode/",target:"_blank",rel:"noopener noreferrer"}},[t._v("What every JavaScript developer should know about Unicode"),v("OutboundLink")],1),t._v("或者"),v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/12/unicode.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Unicode与JavaScript详解"),v("OutboundLink")],1)]),t._v(" "),v("li",[t._v("JS 与 unicode：遍历字符串获得单个 unicode 字符的方法，获取单个 unicode 字符 code point 的方法 codePointAt()")])]),t._v(" "),v("p",[v("em",[t._v("面向对象")])]),t._v(" "),v("ul",[v("li",[t._v("面向对象的基本概念：封装，继承，多态")]),t._v(" "),v("li",[t._v("原型的概念")]),t._v(" "),v("li",[t._v("JS 中 Class 的使用")])]),t._v(" "),v("h3",{attrs:{id:"task-4：a-robot-项目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-4：a-robot-项目","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 4：A Robot 项目")]),t._v(" "),v("p",[t._v("// TODO")]),t._v(" "),v("h2",{attrs:{id:"模块四：web-开发基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块四：web-开发基础","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块四：Web 开发基础")]),t._v(" "),v("h3",{attrs:{id:"task-1：javascript-与浏览器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-1：javascript-与浏览器","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 1：JavaScript 与浏览器")]),t._v(" "),v("p",[t._v("JavaScript 当年是作为 NetScape 浏览器的一个特性出现的。后面 JavaScript 成为了在浏览器中编程的唯一标准。随着互联网的发展，JS 也从浏览器里的一个小特性变为了一门使用非常广泛的主流语言。")]),t._v(" "),v("p",[t._v("我们如何在浏览器中使用 JS？JS/HTML/CSS 三者是如何构成一个页面的？这就是本节要讨论的话题。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("13")]),t._v(" 章，以及下面的拓展阅读材料。")]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[t._v("互联网（Internet）的基础概念：IP 地址，HTTP 协议，URL。")]),t._v(" "),v("li",[t._v("HTML 基础概念：标签语法，doctype，特殊字符转义，兼容语法错误（error-tolerant）。")]),t._v(" "),v("li",[t._v("如何在 HTML 中引入 JS："),v("code",[t._v("<script />")]),t._v(" 标签。")]),t._v(" "),v("li",[t._v("兼容性与"),v("a",{attrs:{href:"https://zh.wikipedia.org/zh-hk/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%A7%E6%88%98",target:"_blank",rel:"noopener noreferrer"}},[t._v("浏览器战争"),v("OutboundLink")],1),t._v("（这个链接需要翻墙）。")])]),t._v(" "),v("p",[t._v("拓展阅读：")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2011/06/birth_of_javascript.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Javascript 诞生记"),v("OutboundLink")],1)]),t._v(" "),v("li",[t._v("浏览器厂商对 HTML/CSS/JS 等技术的实现如果不统一，会对开发者造成很大的困扰。因此需要一个中立的组织来制定 "),v("a",{attrs:{href:"https://juejin.im/post/5c700b1de51d457fd033f496",target:"_blank",rel:"noopener noreferrer"}},[t._v("Web 标准"),v("OutboundLink")],1)]),t._v(" "),v("li",[t._v("浏览器兼容性：IE 对 Web 标准的实现存在很多问题，因此在开发兼容 IE 的网页时，经常需要查阅相关的资料并做特定的处理。后来 HTML5 和 CSS3 普及之后，微软推出了符合 Web 标准的 Edge 浏览器，目前我们一般不需要兼容 IE 了（除了针对银行或者政府的业务）。目前主流的四大浏览器：Chrome，Safari，Firefox，Edge 被称为是常青浏览器（Evergreen Browser），这些浏览器遵守 Web 标准，并且会自动更新，兼容性的问题比较少。")])]),t._v(" "),v("h3",{attrs:{id:"task-2：模块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-2：模块","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 2：模块")]),t._v(" "),v("p",[t._v("理想的程序应该是由多个自治的部分组成的。每个部分各司其职。本节引入了模块的概念。模块是每个主流编程语言（C++/Java/C#等等）都有的一个特性，它让你可以将代码写到一个模块中，控制代码对外暴露（可以从另一个模块访问）的函数和属性。我们通过将代码写成一个一个模块，就可以组成一个结构清晰，易于维护的大型前端应用。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("10")]),t._v(" 章并完成书上习题，上传到 Github")]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("模块")]),t._v("（Modules）的概念。模块就是一段代码，它声明了外部的依赖（dependencies），同时也声明了对外暴露的接口（Interface）。")]),t._v(" "),v("li",[v("strong",[t._v("包")]),t._v("（Package）的概念。Package 就是可以被分发的模块，它有一个描述自身依赖的文件。为了让开发者可以共享代码，JS 有一个统一的包格式和包管理工具："),v("a",{attrs:{href:"http://npmjs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("NPM"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("li",[t._v("JS 一开始没有模块特性，我们有很多方法在 JS 中实现模块的效果："),v("strong",[t._v("立即执行函数表达式（IIFE)，eval 方式，CommonJS")]),t._v("。这些方式有各自的问题。CommonJS 和 NPM 一起出现，是比较常用的模块实现。")]),t._v(" "),v("li",[t._v("ECMAScript modules 是 JS 标准化的模块实现（语言内置）。"),v("strong",[t._v("了解 ES 模块的基本语法以及静态特性")]),t._v("。")]),t._v(" "),v("li",[t._v("浏览器对新的 JS 特性的支持是一个缓慢的过程。同时我们也会使用 "),v("a",{attrs:{href:"http://www.typescriptlang.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("TypeScript"),v("OutboundLink")],1),t._v(" （编译到 JS 的静态类型语言）来为构建大型前端应用提供支持。为了提早使用这些特性，在编写完代码后，我们会对源代码进行"),v("strong",[t._v("编译（compile）")]),t._v("，产生浏览器可以运行的 JS 代码。")]),t._v(" "),v("li",[t._v("一个项目的模块的数量往往很大，但浏览器下载 JS 文件受到网络请求并发数的限制。因此我们在部署 JS 代码时，往往会进行"),v("strong",[t._v("打包（bundling）")]),t._v("，将多个 JS 模块合并为一个文件。")]),t._v(" "),v("li",[v("strong",[t._v("Building and bundling")]),t._v(" 指的就是上述两个步骤，我们经常使用的工具是 "),v("a",{attrs:{href:""}},[t._v("Webpack")]),t._v(" 和 "),v("a",{attrs:{href:""}},[t._v("Babel")]),t._v(" 等等。")]),t._v(" "),v("li",[t._v("目前我们使用 ES Module 编写的代码往往会被转化为 CommonJS，然后在浏览器运行。虽然主流浏览器对 ES Module 都有了支持，但为了兼容性考虑，在未来一段时间内，我们还是需要进行转译。")]),t._v(" "),v("li",[t._v("模块设计是主观的，往往涉及很多利弊权衡（trade-offs），需要开发者进行深入的思考。")]),t._v(" "),v("li",[t._v("模块设计一个重要方面就是要"),v("strong",[t._v("容易使用（ease of use）")]),t._v("，因为不管是自己用还是给其他人用，如果过一段时间之后去看代码，都需要能尽快的想起模块的用法。模块对外暴露的 API 很重要。"),v("strong",[t._v("好的 API 往往是模仿了现存的惯例")]),t._v("。如果你想不到好的 API 设计或者数据结构，最好的办法就是看看已有的开源模块是怎么设计的，并且仿造这个惯例。")])]),t._v(" "),v("p",[t._v("拓展阅读：")]),t._v(" "),v("ol",[v("li",[v("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/module",target:"_blank",rel:"noopener noreferrer"}},[t._v("ES6 标准入门 - Module 的语法"),v("OutboundLink")],1),t._v(" 入门教程")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/module-loader",target:"_blank",rel:"noopener noreferrer"}},[t._v("ES6 标准入门 - Module 的加载实现"),v("OutboundLink")],1),t._v(" 入门教程")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://github.com/Huxpro/js-module-7day",target:"_blank",rel:"noopener noreferrer"}},[t._v("JS 模块化七日谈"),v("OutboundLink")],1),t._v(" 考古向")]),t._v(" "),v("li",[v("a",{attrs:{href:"https://leanpub.com/understandinges6/read/#leanpub-auto-encapsulating-code-with-modules",target:"_blank",rel:"noopener noreferrer"}},[t._v("Understanding ECMAScript 6 - Modules"),v("OutboundLink")],1),t._v(" 深度的参考手册")])]),t._v(" "),v("p",[t._v("小练习：")]),t._v(" "),v("p",[t._v("使用 Webpack 打包 Chapter 7 的 Robot 项目，并用 Babel 把代码转译为 ES5。最后可以在本地用 HTML 看到项目。")]),t._v(" "),v("blockquote",[v("p",[t._v("TODO: 项目文档，项目代码准备。")])]),t._v(" "),v("h3",{attrs:{id:"task-3：dom-api-与事件处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-3：dom-api-与事件处理","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 3：DOM API 与事件处理")]),t._v(" "),v("p",[t._v("HTML 和 CSS 控制页面的结构和样式。在富交互的前端应用开发中，我们需要使用 JS 响应用户的点击事件，并对页面的结构进行动态的修改。")]),t._v(" "),v("p",[t._v("浏览器给 JS 提供了 DOM API，用于动态控制页面的结构和样式，以及用户交互事件的监听。对于现代前端应用（比如购物网站，社交网站，电子邮箱，在线文档）等等来说，这些 API 是必须掌握的。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("14")]),t._v(" 章和 "),v("strong",[t._v("15")]),t._v(" 章并完成书上习题，上传到 Github")]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("p",[v("strong",[t._v("DOM")])]),t._v(" "),v("ul",[v("li",[t._v("浏览器内部存储 HTML 文档的数据结构叫 "),v("strong",[t._v("Document Object Model")]),t._v("，简称是 DOM。")]),t._v(" "),v("li",[t._v("DOM 是一个树结构。可以看这里了解一下"),v("a",{attrs:{href:"https://www.cnblogs.com/jaxu/p/11309385.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("树（Tree）"),v("OutboundLink")],1),t._v("这种数据结构。")]),t._v(" "),v("li",[t._v("DOM 其实是一种标准，是一种"),v("strong",[t._v("抽象的数据结构")]),t._v("。DOM 也可以用来解析 XML。这也是 DOM 中存在 NodeType 或者 Array like Object 的原因。")]),t._v(" "),v("li",[t._v("遍历节点的方式：了解 childNodes，firstChild，lastChild，previousSibling，nextSibling，children 等属性。")]),t._v(" "),v("li",[t._v("查找节点：了解 getElementsByTagName，getElementById，getElementsByClassName 等 API。")]),t._v(" "),v("li",[t._v("插入/删除/替换节点：了解 remove，appendChild，insertBefore，replaceChild 等 API。注意 insertBefore 的参数。")]),t._v(" "),v("li",[t._v("创建节点：了解 createTextNode，createElement 等 API。")]),t._v(" "),v("li",[t._v("属性（Attributes）：DOM 节点有属性，比如 a 标签的 href 等等。我们也可以在节点上加自定义的属性。这些自定义属性要用 getAttribute 和 setAttribute 两个方法去访问。class 这个属性是 JS 里的关键字，所以比较特殊，要用 node.className 访问，或者用 getAttribute['class'] 访问。")]),t._v(" "),v("li",[t._v("布局（Layout）：块级元素（Block Elements） vs 行内元素（Inline Elements）的概念和主要区别。获取元素的宽高可以用 offsetHeght/offsetWidth 或者 clientHeight/clientWidth。两者的区别是前者包括边框，后者不包括。要获取元素的坐标，可以用 getBoundingClientRect 方法，返回的坐标是相对于屏幕左上角的。如果要获取相对整个文档的坐标，就要加上滚动条的位置：pageXOffset 或者 pageYOffset。当我们调用以上属性或者方法去获取元素的布局信息时，会触发浏览器的布局流程，涉及一些计算。因此我们要尽量少的去调用以上的 API。")]),t._v(" "),v("li",[t._v("通过 style 属性我们可以动态的设置元素的样式。带中划线的属性，在 JS 中要使用驼峰命名来获取，比如：font-family -> fontFamily。")]),t._v(" "),v("li",[t._v("查找元素时，我们通常用 "),v("strong",[t._v("querySelector 和 querySelectorAll")]),t._v(" 两个 API。这两个 API 让我们可以用 CSS 选择器去查找元素，非常方便，因此是最常用的。")])]),t._v(" "),v("p",[v("strong",[t._v("CSS")])]),t._v(" "),v("ul",[v("li",[t._v("CSS（Cascading Style Sheets）中的 "),v("strong",[t._v("Cascade 代表层叠")]),t._v("。多个 CSS 选择器可以作用于同一个元素。最终元素的样式是多个样式表叠加的结果。因此 CSS 里有一个重要概念：选择器"),v("strong",[t._v("优先级（specificity）")]),t._v("，也叫选择器权重。CSS 选择器优先级有一套专门的"),v("a",{attrs:{href:"https://juejin.im/post/5be3d07be51d457d4932b043",target:"_blank",rel:"noopener noreferrer"}},[t._v("计算规则"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("li",[t._v("了解 CSS 的 position 属性，"),v("strong",[t._v("相对定位和绝对定位")]),t._v("的概念和区别。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("requestAnimationFrame")]),t._v(" API 的用法和使用场景。")])]),t._v(" "),v("p",[v("strong",[t._v("Event")])]),t._v(" "),v("ul",[v("li",[t._v("在使用页面的时候，我们需要响应用户的输入，比如鼠标点击，或者键盘输入。每一次输入我们可以定义为一次事件。事件可以被放到一个队列里，我们可以定时去查询是否有事件发生。")]),t._v(" "),v("li",[t._v("比定时查询（polling）更好的办法是：操作系统会处理用户的输入，然后通过一种方式通知我们事件发生。")]),t._v(" "),v("li",[t._v("浏览器允许我们注册"),v("strong",[t._v("事件处理函数（handlers）")]),t._v("。API 是 "),v("strong",[t._v("window.addEventListener")]),t._v("。这个 API 接受事件名和一个回调函数（Callback），当指定的事件发生时，这个回调函数就会运行。")]),t._v(" "),v("li",[t._v("我们也可以直接在 HTML 中用 onclick 这样的 on + 事件名 组成的属性来注册事件处理函数。但这样的坏处是只能注册一个函数，并且将逻辑和 HTML 结构耦合，因此我们一般还是用 addEventListener。")]),t._v(" "),v("li",[v("strong",[t._v("removeEventListener")]),t._v(" 用于移除事件注册函数。需要注意的是传入的函数必须和注册时的函数是同一个（同一个引用）。")]),t._v(" "),v("li",[t._v("事件对象是事件处理函数被调用时传入的参数。可以从事件对象的属性中获得事件的相关信息，比如键盘按下了哪一个键等等。")]),t._v(" "),v("li",[v("strong",[t._v("事件冒泡（propagation）")]),t._v("，DOM 树结构中，子节点上触发的事件，也会在所有的父节点上触发（"),v("strong",[t._v("自底向上")]),t._v("，父，祖父，"),v("strong",[t._v("依次触发")]),t._v("）。所有我们把这个过程叫做冒泡。事件对象中的 "),v("strong",[t._v("target")]),t._v(" 属性指向真正触发事件的节点。利用时间冒泡这个特性，在需要批量监听事件时，我们可以把事件注册在父节点上，这样就可以一次监听所有子节点的事件。这种做法被叫做"),v("strong",[t._v("事件代理")]),t._v("。")]),t._v(" "),v("li",[t._v("事件有默认行为，比如 a 标签在被点击时会跳转到对应的链接，滚动事件会使页面发生滚动。我们可以调用事件对象的 "),v("strong",[t._v("preventDefault")]),t._v(" 方法来阻止默认行为。")]),t._v(" "),v("li",[t._v("了解主要事件："),v("strong",[t._v("键盘（Key），点击（Pointer），滚动（Scroll），聚焦（Focus），加载（Load）")]),t._v(" 的事件对象的 API。")]),t._v(" "),v("li",[t._v("JS 是单线程执行的（某一时刻只能执行某一段代码）。因此如果我们执行了大量的计算，就会影响事件的及时响应，事件回调只有在没有 JS 代码运行的时刻才会被调用。对于长时间运行的计算，我们可以用 "),v("strong",[t._v("webworker")]),t._v(" 来解决。webworker 和主线程之间的内存空间的隔离的，因此传参需要进行 JSON 序列化，传给 worker 的是数据的 Copy。")]),t._v(" "),v("li",[v("strong",[t._v("clearTimeout")]),t._v(" 可以用于清除定时器（传入 setTimeout 的返回值）。"),v("strong",[t._v("clearAnimationFrame")]),t._v(" 用于清除 requestAnimationFrame。"),v("strong",[t._v("setInterval")]),t._v(" 用于每隔 X 毫秒执行一个函数。对应的清除函数是 "),v("strong",[t._v("clearInterval")]),t._v("。")]),t._v(" "),v("li",[v("strong",[t._v("节流（debouncing）")]),t._v(" 是一种用来控制事件触发频率的技术。比如 scroll 或者 input 事件，如果频繁触发，并且在事件回调中做了影响性能的操作，就会造成卡顿。此时我们可以用节流和限制事件触发的频率。了解如何使用 setTimeout 实现节流。")])]),t._v(" "),v("h3",{attrs:{id:"task-4：异步编程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-4：异步编程","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 4：异步编程")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("11")]),t._v(" 章并完成书上习题，上传到 Github")]),t._v(" "),v("p",[t._v("代码由处理器（Processor）执行。理想情况下，我们写的代码是按顺序执行的。一个 Web 应用经常需要通过网络获取数据，这个过程需要时间。在这段时间里，处理器不能等待，而是转手去做其他的事情。就像人不会坐等着水烧开，而是在烧水的同时做其他事情，等水开了再把水倒出来。这就是一个"),v("strong",[t._v("事件驱动的异步编程模型")]),t._v("。")]),t._v(" "),v("p",[t._v("所谓的异步，就是我们要其他人做一件事情，但不知道这个事情什么时候会做完，于是我们让对方做完之后通知我们。在对方做完之前，我们会做自己的事情。对于处理器（JS 代码）来说，它需要通过网络请求数据，等数据请求完成了，执行一个回调函数，继续请求完成之后的逻辑。在请求过程中，如果有用户事件产生，处理器就可以做出及时的响应。")]),t._v(" "),v("p",[t._v("本章的故事背景是：传说乌鸦是智力很高的动物，它们用白蚁的巢穴作为计算节点，组成了一个网络，来帮助它们完成计算任务。这当然只是一个虚构的背景，不是事实。本章借虚构的乌鸦通信网络，从 0 开始构建了通信的机制，这其实就是现实中计算机网络的基础。JS 中的异步主要源于网络通信，因此本章用了这样的背景。")]),t._v(" "),v("p",[t._v("学了本章之后，对计算机网络的原理会有一些基本的了解。等今后正式学习网络的时候，会有感触。")]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("深刻理解异步（asynchronous）的概念")]),t._v("。异步相对于同步（synchronous），同步是先等待别人做完 A 再等待别人做完 B，再做下一步。异步是先后触发 A 和 B，等两者都完成了，就做下一步操作。其中，等待 A 和 B 完成用的就是监听事件的方式，A 和 B 完成时会触发监听时给的回调函数，在 A 和 B 完成之后要做的操作就写在回调里面。")]),t._v(" "),v("li",[t._v("关键词："),v("strong",[t._v("单线程，同一时刻只能做一件事。基于回调（事件驱动），就如同开水烧开之后的鸣笛声（事件触发），人听到这个事件之后，被叫回来倒水（回调）")]),t._v("。")]),t._v(" "),v("li",[t._v("课本中还提到了基于 "),v("strong",[t._v("多线程（thread）")]),t._v(" 的模型。线程可以理解为是一个正在运行的程序，操作系统允许我们运行多个线程，来同时运行多个程序。在 Java 后端和客户端编程中，多线程是常见的。但 JS 被设计为是单线程的，这和浏览器的设计有关，浏览器使用一个主线程执行 JS 代码和浏览器的渲染逻辑。多线程有更高的理解和维护成本，JS 的单线程异步模型（基于回调）编写起来比较轻松，代码容易理解。目前单线程异步模型在传统的服务端编程领域也开始有应用。")]),t._v(" "),v("li",[v("strong",[t._v("回调（Callback）")]),t._v(" 是异步编程最基础的方式，当异步操作完成时，在触发异步操作时传入的回调函数就会被调用。回调的问题在于，如果在回调函数中需要进行的操作也是异步的，就需要传入另一个回调。多个异步操作串在一起，会造成很深的缩进层级，我们把这种情况称为：回调地狱。")]),t._v(" "),v("li",[t._v("回调是传染性（contagious）的，处理异步操作的函数本身，也必须是异步的。不然函数返回的时候，内部的异步操作还没有完成。这让基于回调的异步编程很容易出错。")]),t._v(" "),v("li",[t._v("基于回调的方式，函数不能像普通同步函数一样，在函数最后返回一个值。"),v("strong",[t._v("Promise")]),t._v(" 是"),v("strong",[t._v("一种数据类型，代表未来的值")]),t._v("。相比使用回调，我们可以返回 Promise。这种方式要更容易理解。")]),t._v(" "),v("li",[t._v("在 JS 中，Promise 是一个类。我们在使用的时候会实例化出 Promise 对象。Promise 对象其实是对一个值的封装，因为这个值可能在未来的某一个时刻被获取到，目前可能还没有获取，因此我们把这个值放在 Promise 对象里面。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("Promise.resolve，Promise.then，和创建 Promise 的方法")]),t._v("。")]),t._v(" "),v("li",[t._v("异步编程中，特别是网络请求中，失败是经常发生的。了解使用 new Promise 时传入的 resolve 和 reject 两个参数的使用。以及使用 "),v("strong",[t._v("catch")]),t._v(" 方法处理错误。")]),t._v(" "),v("li",[t._v("了解如何使用 Promise 包装基于回调的 API，并在发生错误时自动重试。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("Promise.all")]),t._v(" API 的使用。")]),t._v(" "),v("li",[t._v("Network "),v("strong",[t._v("flooding")]),t._v("，或者叫做 boardcasting（广播）是指在网络中，向所有的节点发送消息。这个功能是通过定义一种特殊类型的请求达到的，在收到这个类型的请求后，节点会把消息发给所有的相邻节点，一传十，十传百，消息最终到达了每一个节点。这个传播的原理和流言蜚语（Gossip）的传播是一样的。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("Generator")]),t._v(" 的基本用法。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("async await")]),t._v(" 的基本用法。")]),t._v(" "),v("li",[t._v("JS 是单线程运行的，同一时刻只能运行一端代码。异步的回调函数，比如 setTimeout，网络请求，用户事件，Promise.then 等等，必须等到没有其他代码在执行时，才会执行。浏览器中负责在合适的时机调度回调函数运行的循环机制叫 Event Loop。")])]),t._v(" "),v("p",[t._v("拓展阅读：")]),t._v(" "),v("ul",[v("li",[t._v("ES6标准入门："),v("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/promise",target:"_blank",rel:"noopener noreferrer"}},[t._v("Promise"),v("OutboundLink")],1),t._v("，"),v("a",{attrs:{href:"https://es6.ruanyifeng.com/#docs/async",target:"_blank",rel:"noopener noreferrer"}},[t._v("async 函数"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/10/event-loop.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("JavaScript 运行机制详解：再谈Event Loop"),v("OutboundLink")],1)])]),t._v(" "),v("h3",{attrs:{id:"task-5：http-基础，js-网络请求与表单元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#task-5：http-基础，js-网络请求与表单元素","aria-hidden":"true"}},[t._v("#")]),t._v(" Task 5：HTTP 基础，JS 网络请求与表单元素")]),t._v(" "),v("p",[t._v("前端开发主要实现基于 浏览器/服务器（B/S） 架构的 Web 应用。前端主要实现浏览器端的界面和逻辑。数据从服务端中获取。浏览器和服务端的通信主要通过 HTTP 协议。本节我们主要了解 HTTP 协议，在 JS 中如何发 HTTP 请求，以及常用的表单元素（用于搜集用户输入的信息）。")]),t._v(" "),v("p",[t._v("阅读教材第 "),v("strong",[t._v("18")]),t._v(" 章并完成书上习题，上传到 Github")]),t._v(" "),v("p",[t._v("知识要点：")]),t._v(" "),v("ul",[v("li",[t._v("了解 HTTP 协议的格式。")]),t._v(" "),v("li",[t._v("了解 "),v("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch",target:"_blank",rel:"noopener noreferrer"}},[t._v("fetch API"),v("OutboundLink")],1),t._v(" 的用法。")]),t._v(" "),v("li",[t._v("处于安全考虑，浏览器禁止跨域的请求。了解跨域的"),v("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy",target:"_blank",rel:"noopener noreferrer"}},[t._v("定义"),v("OutboundLink")],1),t._v("和发送跨域请求的"),v("a",{attrs:{href:"https://juejin.im/post/5c23993de51d457b8c1f4ee1",target:"_blank",rel:"noopener noreferrer"}},[t._v("几种方法"),v("OutboundLink")],1),t._v("，书上讲的主要是 "),v("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/04/cors.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("CORS"),v("OutboundLink")],1),t._v(" 方法。")]),t._v(" "),v("li",[t._v("B/S 架构的 Web 应用通常使用 HTTP 协议 + JSON 格式的请求体进行数据交互。我们利用不同的 HTTP method 表示不同的语义（GET 获取/POST 创建/PUT 更新/DELETE 删除）。HTTP 的 URL 则代表了要操作的资源，比如 "),v("code",[t._v("/user/1")]),t._v(" 代表 id 为 1 的用户。")]),t._v(" "),v("li",[t._v("HTTPS 的基本原理和作用。")]),t._v(" "),v("li",[t._v("了解表单（form）系列元素：form，input，textarea，select。input 元素有很多的 type，可以用于不同的用途，可以重点了解。")]),t._v(" "),v("li",[t._v("form 的 action 代表 form 被提交后发送的 HTTP 请求的 URL。但在现代前端应用中，表单元素不需要被包裹在 form 元素中，我们可以通过 JS 去搜集表单数据，使用 fetch 发送 HTTP 请求。")]),t._v(" "),v("li",[t._v("了解 "),v("strong",[t._v("localStorage/sessionStorage")]),t._v(" 的作用和区别。了解 "),v("strong",[t._v("Object.assign")]),t._v(" API 的用法和使用场景。")])]),t._v(" "),v("p",[t._v("拓展阅读：")]),t._v(" "),v("ul",[v("li",[t._v("Web 应用："),v("a",{attrs:{href:"https://blog.csdn.net/qq_40587575/article/details/79673478",target:"_blank",rel:"noopener noreferrer"}},[t._v("B/S 架构"),v("OutboundLink")],1),t._v("。")]),t._v(" "),v("li",[t._v("现代 Web 应用的数据传输格式往往使用 JSON，对 JSON 不了解的话可以"),v("a",{attrs:{href:"#task-3%EF%BC%9A%E5%AF%B9%E8%B1%A1%EF%BC%8C%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2"}},[t._v("回顾第四章讲到的 JSON")])]),t._v(" "),v("li",[v("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2011/09/restful.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("RESTful API 设计"),v("OutboundLink")],1)])]),t._v(" "),v("p",[t._v("// TODO 设计一个基于 Postman 发 HTTP 请求的 Lab")]),t._v(" "),v("h2",{attrs:{id:"模块五：基于-web-技术的多端-gui-应用开发原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模块五：基于-web-技术的多端-gui-应用开发原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 模块五：基于 Web 技术的多端 GUI 应用开发原理")]),t._v(" "),v("p",[t._v("先大致写一下重点。")]),t._v(" "),v("h3",{attrs:{id:"gui-应用简介"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gui-应用简介","aria-hidden":"true"}},[t._v("#")]),t._v(" GUI 应用简介")]),t._v(" "),v("ul",[v("li",[t._v("什么是 GUI（图形用户界面）应用？")]),t._v(" "),v("li",[t._v("GUI 应用的特点：事件驱动，组件化")])]),t._v(" "),v("h3",{attrs:{id:"组件化思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组件化思想","aria-hidden":"true"}},[t._v("#")]),t._v(" 组件化思想")]),t._v(" "),v("p",[t._v("JS 中，我们可以把代码封装为一个又一个的模块。在 GUI 应用中，我们把界面拆分为一个又一个的组件（Component）。组件是页面的组成部分。拆分组件的目的和 JS 需要模块的目的是一样的，是为了将应用拆分为很多容易维护的小的组成部分。同时也可以拆分出一些原子级的组件，比如按钮，对话框等等，在不同的页面中复用，提升开发效率。")]),t._v(" "),v("p",[t._v("组件在 JS 中，其实就是一个函数，只不过这个函数返回的值，就是 UI 的结构。UI 的结构，在 JS 和浏览器环境下，其实就是 DOM。因此我们可以把组件理解为这样一个函数：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('const Button = () => {\n    const btn = document.createElement("button")\n    cosnt text = document.createTextNode("CLICK ME");\n    btn.appendChild(text)\n    document.body.appendChild(btn)\n}\nButton()\n')])])]),v("p",[t._v("同时我们提出数据驱动的概念，组件 UI 中展示的数据，就是组件这个函数的参数：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('const Button = (props) => {\n    const btn = document.createElement("button")\n    btn.id = "foo"\n    cosnt text = document.createTextNode(props.text);\n    btn.appendChild(text)\n    document.body.appendChild(btn)\n}\nButton({ text: "Click me" })\nButton({ text: "Don\'t click me" })\n')])])]),v("p",[t._v("每次需要修改 Button 组件的文案时，只需要修改数据，并重新调用组件，就可以让组件更新 UI 了。")]),t._v(" "),v("p",[t._v("和这个方式相反的就是直接修改 button 组件的属性，来修改文字：")]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('Button({ text: "Click me" })\ndocument.querySelector("#foo").textContent = "Don\'t click me"\n')])])]),v("p",[t._v("这种直接对 UI 进行操作的方式，叫"),v("strong",[t._v("命令行编程")]),t._v("。前一种通过数据驱动 UI 变化的方式，叫"),v("strong",[t._v("声明式编程")]),t._v("。声明式编程只需要说明预期的 UI 状态是怎样的，然后让框架根据给出的状态，自动更新 UI。这是一种在思维上更高级和轻松的编程范式。")]),t._v(" "),v("p",[t._v("我们可以总结出一个公式："),v("strong",[t._v("UI = f(data)")]),t._v("。f 就是组件函数，data 就是传给组件的参数。调用这个函数会渲染出 UI。")]),t._v(" "),v("p",[t._v("但以上的组件有很多问题：")]),t._v(" "),v("ul",[v("li",[t._v("重新调用时，之前的 DOM 元素没有被清除。需要在组件一开始加一个 document.body.removeChild(document.body, btn)。")]),t._v(" "),v("li",[t._v("老的 DOM 元素如果被清除，元素上的绑定的事件如何被移除？")]),t._v(" "),v("li",[t._v("最大的问题，就是这样的编写方式太繁琐，很难看懂代码，和 HTML 的方式差太远了。")])]),t._v(" "),v("p",[t._v("对此，我们需要引入一些 JS 库。所谓的 JS 库就是别人开发好的一些函数和类，做了一些基础的能力，我们拿来之后可以按照文档使用。")]),t._v(" "),v("p",[t._v("在 UI 开发领域，这个 JS 库就是 "),v("a",{attrs:{href:"https://reactjs.org/",target:"_blank",rel:"noopener noreferrer"}},[t._v("React"),v("OutboundLink")],1),t._v("。使用 React 可以让我们快速和高效的开发 UI 组件。")]),t._v(" "),v("p",[t._v("React 帮我们解决的问题：")]),t._v(" "),v("ul",[v("li",[t._v("对于重新调用组件函数时，新老 DOM 冲突的问题，React 引入了虚拟 DOM 机制。我们可以用 React.createElement 创建虚拟 DOM 元素。React 会负责渲染这些元素为真实的 DOM 元素。DOM 的创建，更新和删除都不用我们操心。")]),t._v(" "),v("li",[t._v("React 还提供了 JSX 插件，我们可以用 HTML 的语法写虚拟 DOM 结构。")]),t._v(" "),v("li",[t._v("React 提供了合成事件机制，自动管理事件的监听和销毁，以及解决事件对象的兼容性问题。")]),t._v(" "),v("li",[t._v("提供了 state 帮助我们在多次组件渲染之间，维护变化的状态。不用把状态放在整个组件树的顶端。")])]),t._v(" "),v("h3",{attrs:{id:"react-基础"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react-基础","aria-hidden":"true"}},[t._v("#")]),t._v(" React 基础")]),t._v(" "),v("ul",[v("li",[t._v("组件的基本语法：组件即函数")]),t._v(" "),v("li",[t._v("JSX: 基本语法，插值，事件监听，如何循环。要理解 JSX，要明白 JSX 最后被编译为什么。JSX 中的插值就是一段 JS 表达式。")]),t._v(" "),v("li",[t._v("React 中如何使用 CSS")]),t._v(" "),v("li",[t._v("props")]),t._v(" "),v("li",[t._v("state 与 useState")]),t._v(" "),v("li",[t._v("props 与 state 的区别")]),t._v(" "),v("li",[t._v("useEffect，useEffect 的依赖")]),t._v(" "),v("li",[t._v("组件的组合，props.children")])]),t._v(" "),v("h3",{attrs:{id:"javasript-与移动端应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javasript-与移动端应用","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaSript 与移动端应用")]),t._v(" "),v("p",[t._v("// TODO")]),t._v(" "),v("ul",[v("li",[t._v("Weex/RN/Flutter")])]),t._v(" "),v("h3",{attrs:{id:"javasript-与小程序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javasript-与小程序","aria-hidden":"true"}},[t._v("#")]),t._v(" JavaSript 与小程序")]),t._v(" "),v("ul",[v("li",[t._v("小程序原理："),v("strong",[t._v("JS 线程和浏览器渲染线程分离")]),t._v("。主要是为了限制能力（不然开发者可以随便访问各种浏览器 API），次要是为了提升性能和体验。因为小程序是一个开放平台，首要目的是不能让开发者做破坏性的事情。")]),t._v(" "),v("li",[t._v("小程序渲染：浏览器的渲染内核，因此 CSS 基本和浏览器中的一致。")]),t._v(" "),v("li",[t._v("小程序逻辑执行：JS，但是单独的 JS 引擎。没有任何多余的 API（Eloquent JS 13 章之后的都没有）。")]),t._v(" "),v("li",[t._v("小程序 = 浏览器中的应用减去所有 API（DOM，BOM，Web API）")]),t._v(" "),v("li",[t._v("小程序提供了自己的全套 API，来对应开发者的功能需求。比如 storage，网络，文件等等。具体看小程序的文档。")])]),t._v(" "),v("p",[t._v("Taro：模仿 React API实现，但不是真正的 React。需要仔细阅读文档。")])])},[],!1,null,null,null);e.default=_.exports}}]);